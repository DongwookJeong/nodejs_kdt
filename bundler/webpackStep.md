개발 자동화 파일 한개, 혹은 몇개로 모두 취합한다면, 클라이언트 입장에서는 비교적 저용량의 에러가 적은 검증된 방식의 코드가 압도적으로 편의성면에서 좋고, 서버 입장에서도 좋다.

바벨은 언어 버전을 원하는 방식으로 바꾸는 것이 목적이고, 번들러는 '자동화', '일원화'가 목적이기에 다루는 볼륨도 번들러와의 할 수 있는 설정의 폭 차이 큼

동전을 먹을순 없지만 동전이 들어가 해석된 자판기에서 나온 음료수는 마실 수 있는 것을 연상
"동전이 값어치를 한다."="정의"
"자판기의 음료수"="원하는 산출물"

package.json 파일을 자유자재로 다루기 때문에 몇가지 주요 설정만 익혀놓는다면, "dependencies", "devDependencies"를 마음껏 다룰 수 있는 것처럼 webpack config파일도 사용하기 편리
percel은 기본기능에 충실, 커스텀에 약한편


npm i -y 
npm i --save-dev webpack
npm i --save-dev webpack-cli
npm webpack -v : 버전확인

설명
- 2번, 3번 단계에서 webpack 모듈 두개를 모두 빌드방식으로 개발환경을 설정했으므로, 실행하려면 해당 로컬 디렉토리 명령줄에서 실행
- 로컬, npm(package.json)에 종속되므로 npm이라는 명령을 먼저 작성해야 함
- 버전체크가 안된다면 전 단계 점검

webpack.config.js 파일 생성
- config, 즉 webpack이 구동되는 기준점이 되는 명세 데이터로 자바스크립트의 형태를 취하고'만' 있는 점이 특징

# - mode :
-- 어떠한 형태로 번들링 할 것인지를 정하는 key로 총 세개만 존재한다.
-- "development" : 개발방식(가독성은 매우 떨어지나, 일반적인 개발 코드처럼 보임)
-- "production" : '제품' 형태. 즉, client에게 보낼 코드로 매개변수, 들여쓰기 등 모든 작업을 최소화 시킨다.(uglify, 어글리파이라고도 부른다, 난독화) 최소화시키므로, 개발코드 레벨에서 요소되는 데이터 용량도 최소화 시킬 수 있다. 
.min.file이라고 붙어 있는 것이 여기에 해당한다.
클라이언트는 코드를 확인 할 필요가 없으므로 개발 가독성에 대한 고려가 굳이 필요없는 것이 주요 관점
-- "none" : 단순 번들링만 진행된다.

# - entry :
-- 직역하였을 때 '진입'에 해당, webpack SW가 번들링할 기준이 될 '메인' 파일을 설정하는 자리이다.
-- "./src/index.js"라고 값(value)을 작성하면, 해당 index.js 기준으로 모든 의존 관계를 끌어모아 번들링 하겠다는 뜻이 된다.

# - output :
-- 번들링이 완료될 js파일을 말 그대로 출력하는 지정값, 기본적으로 두개의 하위 객체가 필요하다.

-- path : 어디에 번들링 파일을 저장할 것인지 정해준다.
--- 보통 distribute의 준말로, dist라는 디렉토리에 저장하는 것이 오랜 관습
--- 경로를 판단하기 위해 path 모듈을 불러와 사용하는데, path 모듈이 지원하는 resolve()메서드를 통해 절대경로 방식으로 dist 디렉토리를 지정하는 편이다. 상대개념으로 join()메서드가 있다.

-- fileName : 파일이름을 무엇으로 정할 것인지 지정해주는 키이며, 관습적으로는 file.bundle.js 혹은 배포용일 경우, file.min.js와 같은 이름으로 빌드버전과 배포버전으로 구분하는 방식을 채택

build라는 커스텀 명령을 지정했다.
npx webpack으로 명령하여도 실행이되며,
npm run build라는 커스텀 명령 방식으로도 실행된다.
"devDependencies"{
  "webpack": "^5.74.0",
  "webpack-cli":^4.10.0"
}